Fi <- calc_acumulada(frecuencia_in = fi)
datos <- data.frame(
xi = xi,
ni = ni,
fi = fi,
Ni = Ni,
Fi = Fi
)
calc_decil_k(datos = datos, k = 0.25)
calc_decil_k(datos = datos, k = 0.75)
calc_decil_k <- function(datos, k) {
return(min(datos$xi[datos$Fi >= k]))
}
calc_outliers <- function(datos, coeficiente = 1.5) {
Q1 <- calc_decil_k(datos, 0.25)
Q3 <- calc_decil_k(datos, 0.75)
IQR <- Q3 - Q1
IS <- Q3 + coeficiente * IQR
II <- Q1 - coeficiente * IQR
outliers <- sapply(datos$xi, function(valor) {
valor > IS || valor < II
})
return(outliers)
}
xi <- c(15,20,21,25,28,29,33,41)
ni <- c(30,25,30,52,45,20,10,1)
fi <- calc_fi(datos_in = xi, ni_in = ni)
Ni <- calc_acumulada(frecuencia_in = ni)
Fi <- calc_acumulada(frecuencia_in = fi)
datos <- data.frame(
xi = xi,
ni = ni,
fi = fi,
Ni = Ni,
Fi = Fi
)
calc_decil_k(datos = datos, k = 0.25)
calc_outliers(datos)
calc_decil_k <- function(datos, k) {
return(min(datos$xi[datos$Fi >= k]))
}
calc_outliers <- function(datos, coeficiente = 1.5) {
Q1 <- calc_decil_k(datos, 0.25)
Q3 <- calc_decil_k(datos, 0.75)
IQR <- Q3 - Q1
IS <- Q3 + coeficiente * IQR
II <- Q1 - coeficiente * IQR
outliers <- datos$xi[sapply(datos$xi, function(valor) {
valor > IS || valor < II
})]
return(outliers)
}
xi <- c(15,20,21,25,28,29,33,41)
ni <- c(30,25,30,52,45,20,10,1)
fi <- calc_fi(datos_in = xi, ni_in = ni)
Ni <- calc_acumulada(frecuencia_in = ni)
Fi <- calc_acumulada(frecuencia_in = fi)
datos <- data.frame(
xi = xi,
ni = ni,
fi = fi,
Ni = Ni,
Fi = Fi
)
calc_outliers(datos)
calc_decil_k <- function(datos, k) {
return(min(datos$xi[datos$Fi >= k]))
}
calc_outliers <- function(datos, coeficiente = 1.5) {
Q1 <- calc_decil_k(datos, 0.25)
Q3 <- calc_decil_k(datos, 0.75)
IQR <- Q3 - Q1
IS <- Q3 + coeficiente * IQR
II <- Q1 - coeficiente * IQR
outliers <- datos$xi[sapply(datos$xi, function(valor) {
valor > IS || valor < II
})]
return(outliers, II, IS)
}
xi <- c(15,20,21,25,28,29,33,41)
ni <- c(30,25,30,52,45,20,10,1)
fi <- calc_fi(datos_in = xi, ni_in = ni)
Ni <- calc_acumulada(frecuencia_in = ni)
Fi <- calc_acumulada(frecuencia_in = fi)
datos <- data.frame(
xi = xi,
ni = ni,
fi = fi,
Ni = Ni,
Fi = Fi
)
calc_outliers(datos)
calc_decil_k <- function(datos, k) {
return(min(datos$xi[datos$Fi >= k]))
}
calc_outliers <- function(datos, coeficiente = 1.5) {
Q1 <- calc_decil_k(datos, 0.25)
Q3 <- calc_decil_k(datos, 0.75)
IQR <- Q3 - Q1
IS <- Q3 + coeficiente * IQR
II <- Q1 - coeficiente * IQR
outliers <- datos$xi[sapply(datos$xi, function(valor) {
valor > IS || valor < II
})]
return(II)
}
xi <- c(15,20,21,25,28,29,33,41)
ni <- c(30,25,30,52,45,20,10,1)
fi <- calc_fi(datos_in = xi, ni_in = ni)
Ni <- calc_acumulada(frecuencia_in = ni)
Fi <- calc_acumulada(frecuencia_in = fi)
datos <- data.frame(
xi = xi,
ni = ni,
fi = fi,
Ni = Ni,
Fi = Fi
)
calc_outliers(datos)
calc_decil_k <- function(datos, k) {
return(min(datos$xi[datos$Fi >= k]))
}
calc_outliers <- function(datos, coeficiente = 1.5) {
Q1 <- calc_decil_k(datos, 0.25)
Q3 <- calc_decil_k(datos, 0.75)
IQR <- Q3 - Q1
IS <- Q3 + coeficiente * IQR
II <- Q1 - coeficiente * IQR
outliers <- datos$xi[sapply(datos$xi, function(valor) {
valor > IS || valor < II
})]
return(IS)
}
xi <- c(15,20,21,25,28,29,33,41)
ni <- c(30,25,30,52,45,20,10,1)
fi <- calc_fi(datos_in = xi, ni_in = ni)
Ni <- calc_acumulada(frecuencia_in = ni)
Fi <- calc_acumulada(frecuencia_in = fi)
datos <- data.frame(
xi = xi,
ni = ni,
fi = fi,
Ni = Ni,
Fi = Fi
)
calc_outliers(datos)
calc_decil_k <- function(datos, k) {
return(min(datos$xi[datos$Fi >= k]))
}
calc_outliers <- function(datos, coeficiente = 1.5) {
Q1 <- calc_decil_k(datos, 0.25)
Q3 <- calc_decil_k(datos, 0.75)
IQR <- Q3 - Q1
IS <- Q3 + coeficiente * IQR
II <- Q1 - coeficiente * IQR
outliers <- datos$xi[sapply(datos$xi, function(valor) {
valor > IS || valor < II
})]
return(outliers)
}
xi <- c(15,20,21,25,28,29,33,41)
ni <- c(30,25,30,52,45,20,10,1)
fi <- calc_fi(datos_in = xi, ni_in = ni)
Ni <- calc_acumulada(frecuencia_in = ni)
Fi <- calc_acumulada(frecuencia_in = fi)
datos <- data.frame(
xi = xi,
ni = ni,
fi = fi,
Ni = Ni,
Fi = Fi
)
calc_outliers(datos)
calc_decil_k <- function(datos, k) {
return(min(datos$xi[datos$Fi >= k]))
}
calc_outliers <- function(datos, coeficiente = 1.5) {
Q1 <- calc_decil_k(datos, 0.25)
Q3 <- calc_decil_k(datos, 0.75)
IQR <- Q3 - Q1
IS <- Q3 + coeficiente * IQR
II <- Q1 - coeficiente * IQR
outliers <- datos$xi[sapply(datos$ni, function(valor) {
valor > IS || valor < II
})]
return(outliers)
}
xi <- c(15,20,21,25,28,29,33,41)
ni <- c(30,25,30,52,45,20,10,1)
fi <- calc_fi(datos_in = xi, ni_in = ni)
Ni <- calc_acumulada(frecuencia_in = ni)
Fi <- calc_acumulada(frecuencia_in = fi)
datos <- data.frame(
xi = xi,
ni = ni,
fi = fi,
Ni = Ni,
Fi = Fi
)
calc_outliers(datos)
# Funciones
# Función que calcula las frecuencias absolutas dados unos datos crudos
calc_ni <- function(datos_in, xi_in) {
ni <- sapply(xi_in, function(valor) {
sum(datos_in == valor)
})
return(ni)
}
# Función que calcula las frecuencias relativas de cada dato
calc_fi <- function(datos_in, ni_in) {
total <- sum(ni_in)
fi <- sapply(ni_in, function(valor) {
valor/total
})
return(fi)
}
# Función que calcula la frecuencia acumulada. Se puede dar la relativa o absoluta para este fin, sirve para ambas
calc_acumulada <- function(frecuencia_in) {
frec_acumulada <- c(frecuencia_in[1])
for (i in 2:length(frecuencia_in)) {
frec_acumulada <- c(frec_acumulada,
frec_acumulada[i-1] + frecuencia_in[i])
}
return(frec_acumulada)
}
# Calcula la media ponderada de unos datos dada su tabla de frecuencias
calc_media_ponderada <- function(datos) {
return(sum(datos$xi * datos$fi))
}
# Calcula el momento de orden "r" (dado) de una tabla de frecuencias
calc_momento <- function(orden, datos) {
media <- sum(datos$xi * datos$fi)
resultado <- sapply(1:length(datos$xi), function(i) {
(datos$xi[i] - media)^orden * datos$fi[i]
})
return(sum(resultado))
}
# Calcula la desviación típica de una tabla de frecuencias
calc_sd <- function(datos) {
media <- sum(datos$xi * datos$fi)
resultado <- sapply(1:length(datos$xi), function(i) {
(datos$xi[i] - media)^2 * datos$fi[i]
})
return(sqrt(sum(resultado)))
}
# Calcula las marcas de clase de una lista de vectores que representan los límites de los intervalos:
# list(c(inf1, max1), c(inf2, max2), ..., c(infN, maxN))
calc_marcas_clase <- function(intervalos){
marcas <- sapply(intervalos, function(valor) {
(valor[1] + valor[2])/2
})
return(marcas)
}
# Dado un valor C(k) y una tabla de frecuencias con sus intervalos inferiores y superiores en columnas distintas, te calcula el percentil en el que cae
calc_percentil_k <- function(ck, datos) {
fila <- which(ck >= datos$vida_media_inf & ck < datos$vida_media_sup)
li_1 <- datos$vida_media_inf[fila]
ai <- datos$vida_media_sup[fila] - li_1
resultado <- ((ck - li_1) * (datos$ni[fila] / ai) + datos$Ni[fila-1] ) * 1/sum(datos$ni)
return(resultado)
}
# Dato un valor k tal que k < 1 (es decir, no en porcentaje sobre 100, sino en decimal) se calcula el decil. Por ejemplo, para calcular Q1 podríamos dar k = 0.25, el P99, k = 0.99, etc
calc_decil_k <- function(datos, k) {
return(min(datos$xi[datos$Fi >= k]))
}
# Dada una tabla de frecuencias y, opcionalmente, un coeficiente diferente a 1,5 podemos calcular todos los outlier de la distribución.
calc_outliers <- function(datos, coeficiente = 1.5) {
Q1 <- calc_decil_k(datos, 0.25)
Q3 <- calc_decil_k(datos, 0.75)
IQR <- Q3 - Q1
IS <- Q3 + coeficiente * IQR
II <- Q1 - coeficiente * IQR
outliers <- datos$xi[sapply(datos$ni, function(valor) {
valor > IS || valor < II
})]
return(outliers)
}
xi <- c(15,20,21,25,28,29,33,41)
ni <- c(30,25,30,52,45,20,10,1)
fi <- calc_fi(datos_in = xi, ni_in = ni)
Ni <- calc_acumulada(frecuencia_in = ni)
Fi <- calc_acumulada(frecuencia_in = fi)
datos <- data.frame(
xi = xi,
ni = ni,
fi = fi,
Ni = Ni,
Fi = Fi
)
calc_outliers(datos)
comparar_dispersion <- function(p1, p2) {
cv1 <- sd(p1) / abs(mean(p1))
cv2 <- sd(p2) / abs(mean(p2))
return(cv1>cv2 ? "La primera población está más dispersa" : "La segunda población está más dispersa")
}
p1 <- c(65,60,65,63,68,70,66,71)
p2 <- c(170,150,168,170,175,171,160,180)
comparar_dispersion(p1, p2)
return(cv1>cv2 ? cv1 : cv2)
comparar_dispersion <- function(p1, p2) {
cv1 <- sd(p1) / abs(mean(p1))
cv2 <- sd(p2) / abs(mean(p2))
return(cv1>cv2 ? cv1 : cv2)
}
p1 <- c(65,60,65,63,68,70,66,71)
p2 <- c(170,150,168,170,175,171,160,180)
comparar_dispersion(p1, p2)
comparar_dispersion <- function(p1, p2) {
cv1 <- sd(p1) / abs(mean(p1))
cv2 <- sd(p2) / abs(mean(p2))
return(ifelse(cv1>cv2, cv1, cv2))
}
p1 <- c(65,60,65,63,68,70,66,71)
p2 <- c(170,150,168,170,175,171,160,180)
comparar_dispersion(p1, p2)
return(ifelse(cv1>cv2, p1, p2))
comparar_dispersion <- function(p1, p2) {
cv1 <- sd(p1) / abs(mean(p1))
cv2 <- sd(p2) / abs(mean(p2))
return(ifelse(cv1>cv2, p1, p2))
}
p1 <- c(65,60,65,63,68,70,66,71)
p2 <- c(170,150,168,170,175,171,160,180)
comparar_dispersion(p1, p2)
plot(x = p1, y = p2)
plot(x = 1:length(p1), y = p1)
comparar_dispersion <- function(p1, p2) {
cv1 <- sd(p1) / abs(mean(p1))
cv2 <- sd(p2) / abs(mean(p2))
return(ifelse(cv1>cv2, p1, p2))
}
p1 <- c(65,60,65,63,68,70,66,71)
p2 <- c(170,150,168,170,175,171,160,180)
plot(x = 1:length(p1), y = p1, col = "blue")
plt(x = 1:length(p1), y = p2, col = "red")
comparar_dispersion <- function(p1, p2) {
cv1 <- sd(p1) / abs(mean(p1))
cv2 <- sd(p2) / abs(mean(p2))
return(ifelse(cv1>cv2, p1, p2))
}
p1 <- c(65,60,65,63,68,70,66,71)
p2 <- c(170,150,168,170,175,171,160,180)
plot(x = 1:length(p1), y = p1, col = "blue")
plot(x = 1:length(p1), y = p2, col = "red")
comparar_dispersion(p1, p2)
lines(barp,
resultado$Fi,
type='o',
col="red",
lwd=2) # 'lwd' es el ancho de la línea
barp <- barplot(resultado$fi,
names.arg=resultado$xi,
col="blue",
main="Frecuencias Relativas",
xlab="Categorías", ylab="Frecuencia Relativa", ylim=c(0, 1))
comparar_dispersion <- function(p1, p2) {
cv1 <- sd(p1) / abs(mean(p1))
cv2 <- sd(p2) / abs(mean(p2))
if (cv1 > cv2) {
return("p1 tiene una mayor dispersión")
} else if (cv1 < cv2) {
return("p2 tiene una mayor dispersión")
} else {
return("Ambas poblaciones tienen la misma dispersión")
}
}
p1 <- c(65,60,65,63,68,70,66,71)
p2 <- c(170,150,168,170,175,171,160,180)
plot(x = 1:length(p1), y = p1, col = "blue")
plot(x = 1:length(p1), y = p2, col = "red")
comparar_dispersion(p1, p2)
comparar_dispersion <- function(p1, p2) {
cv1 <- sd(p1) / abs(mean(p1))
cv2 <- sd(p2) / abs(mean(p2))
if (cv1 > cv2) {
return("p1 tiene una mayor dispersión")
} else if (cv1 < cv2) {
return("p2 tiene una mayor dispersión")
} else {
return("Ambas poblaciones tienen la misma dispersión")
}
}
library(ggplot2)
# Crear un data.frame con los datos
p1 <- c(65, 60, 65, 63, 68, 70, 66, 71)
p2 <- c(170, 150, 168, 170, 175, 171, 160, 180)
# Crear un data.frame con todos los datos y una columna para identificar el grupo
datos <- data.frame(
valor = c(p1, p2),
grupo = rep(c("Peso", "Altura"), each = length(p1)),
x = rep(1:length(p1), 2)
)
# Gráfico usando ggplot2
ggplot(datos, aes(x = x, y = valor, color = grupo)) +
geom_point() +
geom_line() + # Opcional, si deseas líneas conectando los puntos
theme_minimal() +
labs(x = "Observación", y = "Valor", title = "Comparación de Dispersión") +
scale_color_manual(values = c("Peso" = "blue", "Altura" = "red"))
comparar_dispersion(p1, p2)
# Gráfico usando ggplot2
ggplot(datos, aes(x = x, y = valor, color = grupo)) +
geom_point() +
theme_minimal() +
labs(x = "Observación", y = "Valor", title = "Comparación de Dispersión") +
scale_color_manual(values = c("Peso" = "blue", "Altura" = "red"))
# Funciones
# Función que calcula las frecuencias absolutas dados unos datos crudos
calc_ni <- function(datos_in, xi_in) {
ni <- sapply(xi_in, function(valor) {
sum(datos_in == valor)
})
return(ni)
}
# Función que calcula las frecuencias relativas de cada dato
calc_fi <- function(datos_in, ni_in) {
total <- sum(ni_in)
fi <- sapply(ni_in, function(valor) {
valor/total
})
return(fi)
}
# Función que calcula la frecuencia acumulada. Se puede dar la relativa o absoluta para este fin, sirve para ambas
calc_acumulada <- function(frecuencia_in) {
frec_acumulada <- c(frecuencia_in[1])
for (i in 2:length(frecuencia_in)) {
frec_acumulada <- c(frec_acumulada,
frec_acumulada[i-1] + frecuencia_in[i])
}
return(frec_acumulada)
}
# Calcula la media ponderada de unos datos dada su tabla de frecuencias
calc_media_ponderada <- function(datos) {
return(sum(datos$xi * datos$fi))
}
# Calcula el momento de orden "r" (dado) de una tabla de frecuencias
calc_momento <- function(orden, datos) {
media <- sum(datos$xi * datos$fi)
resultado <- sapply(1:length(datos$xi), function(i) {
(datos$xi[i] - media)^orden * datos$fi[i]
})
return(sum(resultado))
}
# Calcula la desviación típica de una tabla de frecuencias
calc_sd <- function(datos) {
media <- sum(datos$xi * datos$fi)
resultado <- sapply(1:length(datos$xi), function(i) {
(datos$xi[i] - media)^2 * datos$fi[i]
})
return(sqrt(sum(resultado)))
}
# Calcula las marcas de clase de una lista de vectores que representan los límites de los intervalos:
# list(c(inf1, max1), c(inf2, max2), ..., c(infN, maxN))
calc_marcas_clase <- function(intervalos){
marcas <- sapply(intervalos, function(valor) {
(valor[1] + valor[2])/2
})
return(marcas)
}
# Dado un valor C(k) y una tabla de frecuencias con sus intervalos inferiores y superiores en columnas distintas, te calcula el percentil en el que cae
calc_percentil_k <- function(ck, datos) {
fila <- which(ck >= datos$vida_media_inf & ck < datos$vida_media_sup)
li_1 <- datos$vida_media_inf[fila]
ai <- datos$vida_media_sup[fila] - li_1
resultado <- ((ck - li_1) * (datos$ni[fila] / ai) + datos$Ni[fila-1] ) * 1/sum(datos$ni)
return(resultado)
}
# Dato un valor k tal que k < 1 (es decir, no en porcentaje sobre 100, sino en decimal) se calcula el decil. Por ejemplo, para calcular Q1 podríamos dar k = 0.25, el P99, k = 0.99, etc
calc_decil_k <- function(datos, k) {
return(min(datos$xi[datos$Fi >= k]))
}
# Dada una tabla de frecuencias y, opcionalmente, un coeficiente diferente a 1,5 podemos calcular todos los outlier de la distribución.
calc_outliers <- function(datos, coeficiente = 1.5) {
Q1 <- calc_decil_k(datos, 0.25)
Q3 <- calc_decil_k(datos, 0.75)
IQR <- Q3 - Q1
IS <- Q3 + coeficiente * IQR
II <- Q1 - coeficiente * IQR
outliers <- datos$xi[sapply(datos$ni, function(valor) {
valor > IS || valor < II
})]
return(outliers)
}
# Dadas dos poblaciones como vectores, compara sus dispersiones usando el coeficiente de variación.
comparar_dispersion <- function(p1, p2) {
cv1 <- sd(p1) / abs(mean(p1))
cv2 <- sd(p2) / abs(mean(p2))
if (cv1 > cv2) {
return("p1 tiene una mayor dispersión")
} else if (cv1 < cv2) {
return("p2 tiene una mayor dispersión")
} else {
return("Ambas poblaciones tienen la misma dispersión")
}
}
library(ggplot2)
# Crear un data.frame con los datos
p1 <- c(65, 60, 65, 63, 68, 70, 66, 71)
p2 <- c(170, 150, 168, 170, 175, 171, 160, 180)
# Crear un data.frame con todos los datos y una columna para identificar el grupo
datos <- data.frame(
valor = c(p1, p2),
grupo = rep(c("Peso", "Altura"), each = length(p1)),
x = rep(1:length(p1), 2)
)
# Gráfico usando ggplot2
ggplot(datos, aes(x = x, y = valor, color = grupo)) +
geom_point() +
theme_minimal() +
labs(x = "Observación", y = "Valor", title = "Comparación de Dispersión") +
scale_color_manual(values = c("Peso" = "blue", "Altura" = "red"))
comparar_dispersion(p1, p2)
